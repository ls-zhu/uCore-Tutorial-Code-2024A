# uCore Lab5 实验报告
姓名：祝令山 学号：2024319220
## 功能总结
1. 死锁检测，实现系统调用int enable_deadlock_detect(int is_enable)，实现如下：  
1.1 proc结构体里增加成员变量deadlock_detect_enabled  
1.2 实现函数sys_enable_deadlock_detect(unit enable)，将curr_proc()->deadlock_detect_enabled设置为参数enable，即实现了死锁检测的开关  
2. 死锁检测算法和实现：  
课程文档给出的算法类似于银行家算法，算法的核心是在申请一系列锁之前先判断这些锁是否都可用，如果都可用则允许按顺序申请锁；如果有任意锁不可用则表明有死锁风险，则不申请锁，进入重试或者错误处理流程。这本质上是一种资源匹配算法，不适合解决死锁问题，存在一定问题，比如：  
a)如果p1和p2两个进程，都按照同样的顺序申请锁a、b、c，那么当p1申请到a的时候，p2试图申请锁的时候就不满足a、b、c都空闲的条件，则会返回-0xdead，但这个时候实际上没有死锁，只是需要p2等待锁释放而已  
b)死锁指的是一些进程持有对方必须的锁而导致所有进程都没法运行，而不是某个进程资源得不到满足的情况  

我们可以看到，类似于银行家算法的死锁检测机制实际上是一种try_lock。所以我们有一种更简单的方法实现这种try_lock:  
2.1 更改mutex_lock和semaphore_down两个函数，让这个两个函数返回int，而不是void  
2.2 在执行mutex_lock(m)的时候，如果curr_proc()->deadlock_detect_enabled == true，而且 m->locked == true，则返回-0xdead  
2.3 在执行semaphore_down(s)的时候，如果curr_proc()->deadlock_detect_enabled == true，而且 s->count <= 0，则返回-0xdead  
**如果用户态发现返回了-0xdead，则需要反照与申请顺序相反的顺序释放已经申请的锁**

如此就实现了一个简便的try_lock。需要注意的是，semaphore实际上不可能是小于0的值，最小就是0。课程代码实际上也不应该依赖count的值来判断是否有任务等待在某个semaphore上，应该判断等待队列是否为空。

## 作业问答  
1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。  
1.1 需要回收的资源有哪些？  
答：需要回收proc相关资源，比如页表和内存，打开的文件，所持有的mutex和semaphore。还需要回收进程下所有线程的资源，比如trapframe和stack
1.2 其他线程的 struct thread 可能在哪些位置被引用，分别是否需要回收，为什么？  
答：其他的struct thread可能在某些mutex和semaphore的等待队列上被引用，也有可能在任务就绪队列上被引用，这时候也要回收，因为随着进程的退出，线程的运行环境也被销毁了  
2. 对比以下两种 mutex_unlock 中阻塞锁的实现，二者有什么区别？这些区别可能会导致什么问题？ （假设无论哪种实现，对应的 mutex_lock 均正确处理了 m->locked)  
答：mutex_unlock_v1发现m->blocking为真就会直接将locked赋值为0(记为t1时刻)，而后在等待队列中取得线程t，再把t设置为RUNNANBLE，加入到运行队列里(记为t2时刻)。这里t1到t2形成了一个较大的时间窗口，因为locked == 0, 所以如果有某个进程恰巧在t1和t2之间申请了锁m, 则有可能成功，这样就会有大于一个线程都认为自己拥有同一把锁，造成错误。  
mutex_unlock_v2只在没有线程等待的情况下才会把锁置零，如果有线程t在等待，则直接让线程变为RUNNABLE状态，并将t加入到运行队列中，所以v2没有造成类似于v1版本的时间窗口,造成多个线程可能进入临界区的问题。但是v2版本的问题是需要相应的修改mutex_lock函数，在线程被唤醒之后，要么跳过锁检测代码，要么把自己的locked=0写进锁，然后紧接着就拿到锁，必须谨慎的实现这个锁在线程间传递的过程。

# 问题和看法
1. ch8不能完整的编译所有测试用例  
2. 银行家算法并不能完美的检测死锁，而只是一种资源匹配，一种try lock  

# 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
>无
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
> 无
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。



